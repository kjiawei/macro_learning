编译gcc hello.c -o hello　`pkg-config --cflags --libs gtk+-2.0`
教程地址：http://tieba.baidu.com/p/1928899283?see_lz=1
大全：http://gtk.awaysoft.com/read-98-1.html
api:http://zetcode.com/gui/gtk2/
https://www.gtk.org/documentation.php
官网：https://developer.gnome.org/gtk-tutorial/stable/
http://blog.csdn.net/column/details/sjin-gtk.html

字符串处理：http://www.jb51.net/article/37410.htm

第一章 Gtk+基础
1 gtk+历史
2 gtk+所用到的库
3 gtk+的一些基本概念
第二章 第一个gtk+程序
1 helloworld
2 如何编译
3 信号、回调和事件
4 按钮
5 控件的属性
6 小练习一个
第三章 容器类控件
第三章 容器构件 
1 GtkContainer 
2 box 
3 pane 
4 table
5 fixed
6 expander 
7 handle 
8 notebook
9 eventbox 
10 小练习一个

第3章 容器类控件
在开始第三章之前，我先把后面章节的目录更新一下（最开始那个目录只到第三章，快不够了）
第4章 基本控件
4.1 综述
4.2 开关按钮
4.3 文字输入
4.4 微调按钮
4.5 横纵向滚动条
4.6 其他按钮
4.7 Gtk主题系统简介
4.7 小练习

第5章 对话框
5.1 内置对话框
5.2 向导对话框
5.3 自定义对话框
5.4 练习

第6章 GLib基础
6.1 综述
6.2 消息日志
6.3 实用函数
6.4 内存管理
6.5 主循环（线程）
6.6 数据类型
6.7 输入输出
6.8 动态加载模块
6.9 极为困难的练习

第7章 文本视图控件
7.1 滚动窗口
7.2 文本视图
7.3 文本迭代器和标记 
7.4 文本标记 
7.5 插入图像 
7.6 插入衍生构件 
7.7 GtkSourceView详解
7.8 练习

第8章 树形视图构件 
8.1 树形视图与树形视图控件
8.2 使用GtkListStore 
8.3 使用GtkTreeStore 
8.4 引用行 
8.5 添加行、选择行 
8.6 可编辑的文本渲染器
8.7 单元数据函数 
8.8 单元渲染器 
8.9 练习

第9章 菜单和工具条 
9.1 弹出式菜单
9.2 快捷键 
9.3 状态栏 
9.4 菜单项 
9.5 菜单栏 
9.6 工具栏 
9.7 工具项
9.8 创建动态菜单 
9.9 自定义预置项 
9.10 练习

第10章 神器之glade
10.1 设计用户界面 
10.2 Glade用户界面编辑器
10.3 使用GtkBuilder
10.4关于连接事件
10.5 练习

第11章 神器之anjuta
11.1 anjuta简介
11.2 用anjuta编写程序
11.3 练习

第12章 神语言vala
12.1 vala简介
12.2 vala基础
12.3 vala程序示例
12.4 练习

第13章自定义控件
13.1 继承控件
13.2 从零开始构建控件
13.3 实现接口
13.4 练习

第14章 其它控件简介
14.1 绘制构件 
14.2 日历 
14.3 状态图标 
14.4 打印支持 
14.5 Cairo绘制上下文
14.6 最近访问文件 
14.7 自动完成 
14.8 VTE
14.9 练习

第15章 如何进一步学习

指针和结构体关系以及为什么重要
首先，建立一个GtkWidget类型的指针。对于每一个gtk控件，都需要建立一个GtkWidget类型的指针。为什么是指针呢？因为C语言不是面向对象的，对于一个控件，它内部包含很多复杂的信息，例如一个窗体包括标题是什么，大小多少，位置在哪，包括计算机如何在屏幕上显示这个窗体，在窗体上单击最小化、关闭等按钮要进行什么操作等，要用一个struct来保存。为了表示各种各样的控件，就需要一个建立指针，为它动态的分配内存、动态的把它删除，而不能直接建立一个各种表示控件的struct，因为这样每次操作这个控件时，系统资源会消耗很大。而且，GTK只提供了对这种指针的初始化函数，如果你直接建立一个struct，就很难对它初始化。另外要注意的是一般都建立指向GtkWidget的指针而不是GtkWindow、或是GtkButton这类指针。

按钮的属性。
边框样式：（见上一节的程序）
void gtk_button_set_relief (GtkButton *button,
GtkReliefStyle newstyle);
GtkReliefStyle gtk_button_get_relief (GtkButton *button);

标签（按钮上的文字）：
const gchar * gtk_button_get_label (GtkButton *button);
void gtk_button_set_label (GtkButton *button,
const gchar *label);

使用gtk内置的图片和相应的文字（以后会详细介绍）：
gboolean gtk_button_get_use_stock (GtkButton *button);
void gtk_button_set_use_stock (GtkButton *button,
gboolean use_stock);


对齐：
void gtk_button_set_alignment (GtkButton *button,
gfloat xalign,
gfloat yalign);
void gtk_button_get_alignment (GtkButton *button,
gfloat *xalign,
gfloat *yalign);

图片：
void gtk_button_set_image (GtkButton *button,
GtkWidget *image);
GtkWidget * gtk_button_get_image (GtkButton *button);
void gtk_button_set_image_position (GtkButton *button,
GtkPositionType position);
GtkPositionType gtk_button_get_image_position (GtkButton *button);
void gtk_button_set_always_show_image (GtkButton *button,
gboolean always_show);
gboolean gtk_button_get_always_show_image (GtkButton *button);
另外补充一点，新建按钮时有四种方式：
GtkWidget * gtk_button_new (void);
GtkWidget * gtk_button_new_with_label (const gchar *label);
GtkWidget * gtk_button_new_with_mnemonic (const gchar *label);
GtkWidget * gtk_button_new_from_stock (const gchar *stock_id);
第一种方式最灵活，建一个空按钮，连文字也没，需要在上面放gtk_box再放置控件，不过这样就可以想放什么放什么。
第二种就是新建带文字的按钮。
第三种是新建文字上可以带下划线的按钮_表示下划线，可以用Alt+_后面的字母来快速访问这个按钮。
第四种是建立内置的按钮（以后详细介绍stock）

1.2 Gtk+用到的库

最开始当然是xwindow，这是所有linux下图形界面的基础。
在1984年，Jim Gettys和Bob Scheigler在马萨诸塞工业大学创建了X Window系统（X11），作为一个平台无关的显示环境，目的是调试Argus系统。现在X.Org基金会负责开发X11，它成为一个Linux和类Unix操作系统标准的显示引擎。作为最基本的平台，X11为窗口提供了位图显示功能。 
现在X Window系统被用于Linux和其他操作系统，比如微软的Windows不适用它。然而，GTK+的另外一个好处，就是它隐藏了和底层渲染系统进行交互，无论你使用的是什么系统。这样你的代码就一样了，无论你是在Linux、Windows或Mac OS X上开发的。
回到Linux，X11在最基本最抽象的层面管理窗口。它在屏幕上画出了窗口，操作图形环境。在图形环境中，X11同时控制输入设备，比如鼠标和键盘。 
X11基本的编程接口是Xlib，它提供了创建图形显示界面的工具。尽管基于XLib开发是可能的，但是大部分程序员更情愿使用一个类似GTK+的图形工具集，因为大部分底层调用都被这些库隐藏了。 
X11独步天下一个最主要的特性，就是它假定服务器和客户端是彼此无关的。这使得客户端可以脱离服务器，在远程运行。
注意： X Window系统的客户端和服务器定义和传统定义有些区别。客户端是运行应用程序的机器。服务器端指的是用户本地显示，而不是远程机器。 
X Window系统的另外一个好处，就是它没有限定界面风格。这使得图形显示界面（GUI）可以随心定制。这就是为什么桌面管理器可以提供如此不同的界面和主题。这使得几天的Linux用户拥有了选择的自由。 
讽刺的是，这种自由居然成为谴责X11的 一个最重要的理由。许多人惧怕这会造成Linux程序员社区的分裂。但是迄今为止，我们还可以继续享受桌面管理器给我们带来的欣喜，选择最适合我们需要的。 
你，作为一个程序员，不需要直接使用X Window系统，因为GTK+库已经帮你做了。你可以创建窗口和控件，你可以操作这些界面和用户进行交互，所有的屏幕渲染和XLib底层函数调用都自动完成了。 
因此，本教程不再涉及X Window系统，而是集中在GTK+库上。欢迎你主动去寻找关于X11、X.Org基金会更多的材料，www.x.org。
另外，现在linux下出现了一个新的接替者：wayland，目前它还很难超越x11，但是这一天估计终究会来临。使用gtk不需要关心这个问题，因为gtk已经支持wayland了，而且编出的程序也不会有任何区别，这也是gtk的一个优点吧。

Gtk还依赖于一些其他的库，
Cairo
从版本2.8以后，一个二维图形渲染引擎，叫做Cario，提供了渲染功能。Cairo的创建，是为了在不同平台和系统中提供一个稳定的矢量图形渲染功能。它也允许窗口管理器使用硬件加速，如果硬件有这个能力。 
简单的说，就是gtk利用cairo来绘制控件。 
这个教程不包含Cario本身，除了和GTK+打印API有关的内容，因为这些调用您需要和GTK+底层打交道。如果您打算修改GTK+源代码的话，这也是一个很重要的领域您需要探索。访问www.cairographics.org，您可以获得关于Cairo更多介绍。
GLib GLib是一个用于非图形功能的用途广泛的工具。GTK+需要用到GLib，但是它也可以独自工作。正因为如此，有些应用程序使用GLib，不用包含GTK+库，就可以提供很多功能。 使用GLib一个主要的好处是它提供了一个跨平台的接口，让你的代码可以在不用的操作系统中运行，仅仅需要轻微修改，而不是完全重写。GLib的另外一个优势就是它为开发人员提供了丰富的数据类型。 GLib为C程序员提供了一些数据类型，这些数据类型默认也被其他语言所支持，比如单向和双向链表。其他一些数据类型包括双端队列、自平衡二叉树和不平衡n叉树。 . 哈希表允许您创建数据指针的队列。它们和链表不同，因为访问元素不是通过一个整数引用，而是另外一个指针作为键值。 . 

GLib的字符串和C++有点类似，因为他们都是一个随着数据的增加自动增长的文本缓冲区。他们都和printf()很好地集成在一起。 . 相同大小的内存片是创建内存段的高效实现方式。他们也可以用来创建相同大小的元素队列。在GLib 2.10发布以后，这个结构被内存段替换。 . 在简单的API中， 缓存让你共享巨大的、复杂的数据结构，这有助于您节省空间。这些被GTK+应用于风格和图形设备上下文，因为这些内容都开销巨大。GLib提供了其他数据类型，其中许多都会在第六章介绍。另外，GLib实现了除数据类型之外的其它特性。它还给您提供了很多各种类型的工具函数。举例来说，您会发现文件管理的工具函数、支持国际化的、字符串、警告、调试标志、动态加载模块、自动结束字符串等等。 在第六章中，您将学习到空闲函数，超时函数，以及定时器――所有这些为开发者提供了一个有趣而强悍的平台。空闲函数允许您调用一个函数，当处理器处于空闲状态时。超时函数可以在一个指定的时间以后调用一个函数。在初始化一个计时器以后，它可以时刻跟踪时间的流逝。这些函数分别可以被用来在空闲的时候检查更新，用来实现自动保存，或者用来记录花费的时间。 因为GLib具有跨平台的特性，使得分叉进程、文件访问、内存管理和线程的应用更为方便。对于跨平台的开发者来说，上述任何一项都是噩梦。GLib帮你应付了这些麻烦，这样您就不需要担心跨平台兼容性问题了。我还单独写了一个glib的教程，也是每周两更新的：
http://tieba.baidu.com/p/1928886753

特别介绍几个glib的和gtk关系最大的几个概念
GObject 本来，以GtkObject类的形式来描述，GLib Object System (GObject)是GTK+ 1库的一部分。GTK+ 2.0发布以后，这些内容被放到了它自己的库中，随GLib一起发送。 GObject由于它的复杂性饱受批评，因为它的API提取似乎非常极端。然而，它最初设想是允许从其它语言中轻松访问C对象。虽然是它是通过c语言实现的，但是能从其它语言访问C对象的功能，为它提供了更广泛的应用舞台。 最困难的是：每个开发语言都有不同的数据类型，无论这些不同看起来在表面或者内部。举例来说，在C里面，你有的数据类型是字符、长整数和整数。其他编程语言，比如Perl，没有类似的数据结构，因为变量的类型在使用的时候才确定下来。GObject终于解决了这些限制，缺点就在于创建新对象是个复杂的过程。 GObject也用C写了一个完全面向的接口，这些内容的细节贯穿于本节和本书余下的章节中。这个系统是GTK+构件继承结构的基础，同时也是许多GTK+支持库的基础。GObject面向对象的编程接口，有些是由通用的、动态的数据类型来实现的，名字叫GType。GType允许程序员通过单继承类结构，来实现许多不同的动态的数据类型。单继承是对象继承的形式之一，意思是每个子类有且仅有一个父类。在本书的第二张中，我们还将讨论这个话题，在您了解了GTK+构件以后。 除了创建扩展的数据类型，GObject为程序员提供了许多基本数据类型，又称“非类”（nonclassed）数据类型。所谓“非类”数据类型，就是一个根部的类，其它类由它派生。有一点很重要，根类不从任何其它的类继承而来。 “Table 1-1”提供了一个列表，包括最重要的“非类”数据类型。每个成员都给出了GType宏、C变量描述符和一个描述，有的还包括取值范围，如果有的话。 Table 1-1 标准 GObject “非类”数据类型GType C 类型 描述
G_TYPE_NONE 空数据结构，等价于voidG_TYPE_CHAR gchar 等价于标准C的char

G_TYPE_INT gint 等价于标准C的int。取值范围是从G_MININT到G_MAXINT。
G_TYPE_LONG glong 等价于标准C的long。取值范围是从G_MINLONG到G_MAXLONG。
G_TYPE_BOOLEAN gboolean 标准的布尔数据类型，包括TRUE或者FALSE。
G_TYPE_ENUM GEnumClass 标准的枚举数据类型，等价于C的enum。
G_TYPE_FLAGS GFlagsClass 位域，用来包含多个布尔标志。
G_TYPE_FLOAT gfloat 等价于标准C的float。取值范围从-G_MAXFLOAT到G_MAXFLOAT。
G_TYPE_DOUBLE gdouble 等价于标准C的double。取值范围从-G_MAXDOUBLE到G_MAXDOUBLE。
G_TYPE_STRING gchar* 等价于以空为结束符的C字符串。
G_TYPE_POINTER pointer 一个未定类型的指针，类似于void*。 GObject为GTK+提供了另外两个重要的数据类型：GValue和GObject。GValue是一个通用的容器，它可以包含任何已经定义的结构。这允许函数可以返回任意数据类型的一段数据。如果没有GValue，GTK+面向对象的特性就无从谈起。 G_TYPE_GOBJECT，亦即GObject，是GTK+构件类继承关系的基础。它允许构件从他们的父类继承属性，包括样式属性和信号。 GObject是一个单继承系统，只允许每个子类有且仅有一个父类。子类继承了父类的全部特性，从各方面来看，子类就是父类！在第11章中，你可以了解如何使用这个系统来实现继承自定义的GTK+构件。 GObject同时为构件提供了信号系统，对象属性系统和内存管理。在下一章中我们将逐一探索这些内容。 
GDK
GIMP Drawing Kit（GDK）是一个计算机图形库，最初设计为X Window系统封装底层绘制和窗口功能。GDK扮演的角色位于Xlib和GTK+之间。 在GTK+应用程序中，它负责渲染图像、矢量图形、光标和字体。同时，既然它存在于每个GTK+程序中，GDK还负责处理拖拽和窗口事件。
GDK为GTK+构件提供了画屏幕的能力。为了实现这个目的，每个构件都会和一个GdkWindow对象相关联，除了几个构件不需要它，我们在后面会谈到。GdkWindow本质上是一个屏幕上的矩形区域，在这个区域中画出构件。GdkWindow同时允许构件截获X Window系统的事件，这会在下一章中谈到。 GDK现在被移植到Windows和Mac OS X中。在GTK+ 2.8以后，Cario依然被包含进来。 GdkPixBuf GdkPixBuf是一个较小的库，它提供了客户端图像管理功能。它创建的时候是作为GNOME Imaging Model （Imlib）的替代。图像可以从文件中载入，也可以通过库函数直接喂数据。在后面的章节中，我们会看到，当给树形控件添加图像的时候，当创建GtkImage构件的时候，我们会用到它。
GtkPixbuf的一个优势就是它使得图片可以交叉引用。这意味着一个GdkPixbuf图像可以被同时显式到多个地方，而图像数据存储在一块内存之中。只有在所有的引用都消失、引用计数器归零时，它才会被销毁。
GdkPixbuf库继承了Libart的优点，那是一个随GNOME一起发布的二维图像库，它使用了图像矩阵变换技术。正因此如此，你可以自由缩放、旋转和错切图片。使用GdkRGB库，图片会被渲染到可绘制区域。通过使用这么一个专门的库，GdkPixbuf的图像渲染能力很强。
GdkPixbuf，虽然是一个较小的库，却提供了与图片管理和显示相关丰富的功能。在本书中，这个库作为最基本的应用。关于GdkPixbuf更高级的 话题，请自行参阅它的API文档。 

Pango GDK负责处理渲染图像和窗口的同时，Pango负责控制文本和字体输出，输出关联的是Cairo或者Xft，这和你的GTK+版本相关。它也可以直接渲染到一个内存缓冲区，这种情况不再需要额外的库来支持。

注意：Pango一词的pan，发源于希腊单词，意思是“所有的”；go来源于日本的单词，意思是“语言”。这个名字源于设计它的目的就是为了支持所有的语言，让它成为一个国际化字体渲染引擎。 对于Linux客户端字体，Pango使用的是FreeType和fontconfig库。让Pango与众不同的原因就是因为它支持许多语言。几乎全世界所有的语言都支持，这让应用程序从此不在为国际化而发愁。 Pango内部使用的所有文字都是用UTF-8编码。使用UTF-8时为了能和那些8-bit软件兼容，这种软件在UNIX平台上还是很常见的。UTF-8编码的偏移量是基于字符的，不是固定bits，因为每个字符可能占用不止一个字节。在第七章中你将学习如何使用GtkTextView构件，这点尤其重要，因为你不得不设置字符的偏移量，它们可不一定总是一个字节。 Pango支持很多字体属性。举例来说，这些属性包括语言、字体、风格、字重、拉伸、字号、前景颜色、背景颜色、下划线、删除线、上升、外形和比例。不限于上面这些属性，很多属性自己还提供了多种选项。
为了方便，Pango标记语言提供了一系列的标签，它们代表文本的属性，形式上类似于HTML。用了这些标记语言，你可以在一个构件中为某段文本轻松地改变字体风格。当使用Glade User Interface Builder创建用户界面的时候，这点尤其有用，因为你可以在某个构件的文本内容区域里面直接输入标签。
在后面的章节中，我们有很多例子都会用到Pango，当我们需要修改构件字体的时候（不使用默认值）。使用PangoFontDescription对象或者Pango 标记语言都可以完成这项工作。
ATK 当设计一个软件的时候，需要考虑到一些身有残疾的用户，这点十分重要。因此，Accessbility Toolkit （ATK）为所有GTK+构件提供了内置的方法，来处理易用性问题。 ATK的一些例子添加了对屏幕读取的支持，还有显示高对比度主题的功能，这些都是为了方便视力有障碍的人士使用；键盘修改器，比如修改粘滞键，服务于行动不方便的人群。
尽管这部分对于设计一款软件产品十分重要，但是我就不在这里详细介绍了，以后会发一个单独的帖子加以介绍
当您准备在您的应用程序中处理ATK问题的时候，您应该时刻留意易用性的问题并且记得重新研究这个库，这点十分重要。


1.4 基本概念
GObject 
简单的说glib提供的C语言面向编程的一种方法，我在后面会提到用它实现一些自己的类
GtkWidget 
所有gtk控件的父类
语言 
能用于gtk的语言很多，主流的语言（前20）都可以，本教程用gtk最常用语言------C，以后会发一个python和c++的使用。
属性和方法 
gtk中对象的属性和方法是只能通过函数来模拟的，所以函数的名称都比较长。属性就是比如说按钮的大小、外观、上面显示的内容等等。方法在gtk中主要就是访问各种属性的函数，例如一个显示文字的标签可以用gtk_label_set_text来设置上面的文字。
回调函数
gtk程序运行后就由gtk自动控制程序的运行了，所以要想在其中执行一定编程者事先想好的一些操作就需要通过回调函数来取得对程序的控制权，最常见的就是事件。
事件
一个控件在被用户进行操作后返回去执行一个函数，例如单击按钮就是一个事件，开发者可以将这个事件和自己定义的函数连接起来，这样单击按钮时就会执行指定的函数（一般是自己编写的）
glade
gtk程序用大量的语句来描述界面，将各种事件连接到相应的函数，代码冗长又不直观，所以就有了glade界面设计工具，它类似于visual studio或者delphi，可以设计所见即所得的界面以及连接事件与函数。不过它不提供编写代码的功能。一般是设计好界面后新建一个c文件，通过一定的代码取得这个界面并显示出来，后面我会专门介绍。虽然有了glade，但是熟练掌握普通的gtk代码编写也是很有必要的，因为属性都是通过各种函数来访问的，这些函数还是要掌握的。


3.1 GtkContainer
所有gtk里可以放置其他控件的控件都继承自GtkContainer，这个类似于一个接口。所有GtkContainer分为两类，含其他用途与不含其他用途，分别称为装饰容器，后者称为布局容器。装饰容器有GtkWindow、GtkButton等，而布局容器则是我们这一章要重点介绍的，布局容器本身一般是不可见的。
作为装饰容器一般都是只能放一个子控件，而布局容器可以放多个子控件。像前面的GtkWindow就只能放一个，这种只能放一个的控件继承自GtkBin接口，这个接口是GtkContainer的子类。画个结构图：
---------------------------GtkWindow
------------------GtkBin
GtkContainer
-----------------other
GtkBin类只提供了一个函数，gtk_bin_get_child()，获得它的子控件。
GtkWidget* gtk_bin_get_child (GtkBin *bin);
从GtkBin继承的构件包括窗口、按钮、条目、组合列表框、事件盒子、放大器、事件盒子、滚动窗口、工具条等

课外：编写一个在调整窗体大小时动态调整每个按钮大小和位置的函数，这样一般会很卡，需要使用双缓冲俩显示，这在vc里面没有个四五百行是不行的），而gnome下的扫雷就可以改变窗体大小，雷区的大小和位置会自动调整，很方便。


gtk布局控件这部分内容非常重要

gtk控制布局的方式很简单，它从上到下递归的考虑每个控件需要多大空间，再根据屏幕大小、字体等因素合理分配每个控件的位置和大小。我们可以设置给gtk布局时作为参考的控件大小（注意，是参考，不一定可以实现，虽然后面也会讲到强制的方法，不过不推荐，因为只有在“万般无奈”下gtk才会不采取你的参考大小，此时如果强制它必须按照那个大小的话一般会惨不忍睹）

=========================做项目的经验体会========================
1.看别人写的复杂代码:
    （1）有耐心，简化别人的代码(比如if屏蔽掉，因为if是特殊情况)
                取特殊值，把自己想像成cpu严格按照C语言的语法规则跟逻辑顺序去执行一遍
                打印关键性的变量值
                在关键性的语句前后加一些简单的打印
    （2）做项目之前想画好流程图（先从最简单的版本去做，不要贪心）
         流程图中分解出来的每个步骤你是否在学习的时候真的掌握？？？？
         将各个模块按照你设计的逻辑串起来(通过多做几次项目去感悟别人是用什么方法将代码串起来的，仔细体会，反复推敲)



========================线程的取消=======
1.默认情况，新建的线程是可以被取消(适当的时候取消)
  适当的时候取消（延时取消）----》线程会继续运行到下一个取消点的位置才退出
         所谓的线程取消点指的是POSIX标准规定一系列函数(printf就是代表之一)，区别立即取消
2.线程不能随便乱取消
     （1）特别是线程当中使用了互斥锁，不可以随便取消该线程，会导致死锁
        由于互斥锁的特点是： 谁上的锁谁解锁，别的线程无法解锁(解铃还需系铃人)
                            先拿到锁的线程，可以使用该锁，但是后面的线程要使用锁就会阻塞

        #include <pthread.h>
       void pthread_cleanup_push(void (*routine)(void *),
                                 void *arg);
                   
       void pthread_cleanup_pop(int execute);


=================线程的属性============
1.线程的分离属性
      线程的分离：指线程在退出的时候，自己回收，不需要主线程主动去回收它(自己动手丰衣足食)
      默认情况下线程是不可分离（主线程需要主动调用pthread_join()去回收线程）
    （1）设置/获取线程的分离属性
            方法一：
       int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
                  形参：attr  ---》线程的属性
                        detachstate ---》PTHREAD_CREATE_DETACHED    可分离
                                         PTHREAD_CREATE_JOINABLE    不可分离 （默认是不可分离的）
            方法二：
       int pthread_detach(pthread_t thread);

       int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);
    （2）设置线程属性的一般方法(线程的属性有很多，其他属性的设置思路基本类似)
           步骤一：先定义一个pthread_attr_t类型的变量，并使用pthread_attr_init()对这个变量初始化
                     int pthread_attr_init(pthread_attr_t *attr);  //初始化线程的属性
                     int pthread_attr_destroy(pthread_attr_t *attr); // 销毁线程的属性变量
           步骤二：针对你想设置的属性调用对应设置函数(一定要先将属性变量初始化)
           步骤三：设置完毕，在代码结束之前调用pthread_attr_destroy销毁属性

2.线程的优先级和调度策略（实时系统，非实时系统）
        实时---》时间要求很苛刻
   线程的静态优先级和动态优先级
     静态优先级：0----99，其中0表示非实时线程，数字越大，优先级越高
                             1--99是实时线程的优先级
     动态优先级：跟静态优先级是0的非实时线程有关，-20---19  数字越大，优先级越低
   调度策略：
           （1）先进先出   针对实时线程(1--99),可以去抢占非实时线程的资源
           （2）轮询 ---》时间片轮转 cpu给每个线程分配一个固定的时间片
           （3）针对非实时线程进行调度 ---》所以静态优先级必须设置为0
   设置动态优先级、静态优先级（切换成超级用户）
           //设置静态优先级
           int pthread_attr_setschedparam(pthread_attr_t *attr,
                                      const struct sched_param *param);
                 struct sched_param
                  {
                     int sched_priority;   优先级   0--99
                  }
           int pthread_attr_getschedparam(pthread_attr_t *attr,
                                      struct sched_param *param);
           //设置动态优先级
                int nice(int incr);

3.线程还有一些其他属性，日常开发很少去设置，如果你想要设置，套路是类似




==============================线程间的同步与互斥============
1.线程间的同步互斥：互斥锁，条件变量，信号量(POSIX无名信号量)
    （1）互斥锁
         一：相关的API 互斥锁的初始化
     int pthread_mutex_destroy(pthread_mutex_t *mutex);
     int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);
              形参：pthread_mutex_t 锁类型变量  表示一把锁
                    pthread_mutexattr_t 互斥锁的属性  一般设置为NULL 表示使用锁的默认属性
         二：互斥锁的操作
             上锁跟解锁
         int pthread_mutex_lock(pthread_mutex_t *mutex);
                   如果某个线程已经上了锁，那么其他的线程想要上锁就会阻塞
         int pthread_mutex_trylock(pthread_mutex_t *mutex);
                   如果某个线程已经上了锁，那么其他的线程想要上锁不会阻塞，会退出
         int pthread_mutex_unlock(pthread_mutex_t *mutex);
                   解锁
         三：互斥锁的特点
             特点一：谁上锁谁解锁，不能交叉
             特点二：如果某个线程已经上锁，其他线程还想上锁就会阻塞

练习：
      创建两个线程，必须线程一先操作全局变量i，让i加一，然后才是线程2操作全局变量i，让i减一 ，必须严格轮流来

=============进程间的通信（本地通信，不能联网的）=========
1.管道（有名管道和无名管道）
     （1）无名管道
            特点：读端和写端是固定死的，说白了进程就是通过这个"管道"来发送接收数据的(数据临时存放的地方)
                  只能用于具有血缘关系的进程之间通信  父子  兄弟之间
                  无名管道没有名字 
            相关的API:
                一：管道的创建
                    #include <unistd.h>
                       int pipe(int fildes[2]);
                             返回值：成功返回0   失败  -1
                               形参：fildes[0]   读端
                                     fildes[1]   写端
     
练习：
      使用无名管道实现父子进程之间的双向聊天

     （2）有名管道
            特点：会自动生成一个管道文件用于进程间的通信
                  有名管道没有血缘要求
                  有名管道只能在纯粹的linux环境下创建
                  有名管道不能重复创建（你创建之前要判断一下有名管道是否存在）
                  有名管道用只写的方式打开，那么一定要有一个进程以只读的方式去读出数据，那么只写的那个进程才会解除阻塞退出
              一：有名管道的创建
               #include <sys/types.h>
               #include <sys/stat.h>

                int mkfifo(const char *pathname, mode_t mode);
                          返回值：成功返回0   失败  -1
                            形参：pathname ---》你指定的管道文件的路径
                                  mode     ---》用八进制数字去设置管道的权限
       access()


========================SYSTEM-V  IPC通信方式==========
1.SYSTEM-V  IPC通信方式：共享内存，消息队列，信号量
                   ipcs -q: 查看消息队列
                   ipcs -a：查看所有IPC状态
			-m：查看共享内存状态
			-s：查看信号量
                   删除共享内存  ipcrm -m  共享内存的id号
          （1）共享内存---》是所有进程间通信方式中效率最高
              一：申请共享内存
                  shmget()
                #include <sys/shm.h>
                  int shmget(key_t key, size_t size, int shmflg);
                    返回值：成功会返回共享内存的id号
                            失败  -1
                      形参：key  ---》
                                 获取key值的方法有两种
                                     方法一：shmget((key_t)2000, size_t size, int shmflg)
                                     方法二：使用ftok()生成key值
                                          #include <sys/types.h>
                                          #include <sys/ipc.h>
                                              key_t ftok(const char *pathname, int proj_id);
                                                     形参：pathname ---》任意一个合法的路径
                                                           proj_id  ---》任意一个整数
                           size ---》你打算申请多大的共享内存空间 （页的整数倍）1024整数倍
                           shmflg ---》IPC_CREAT  IPC_EXCL
              二：映射---》让进程能够正常使用共享内存
                  shmat()
                 #include <sys/shm.h>

                 void *shmat(int shmid, const void *shmaddr, int shmflg);
                         返回值：映射得到的内存空间的首地址
                                 失败  NULL
                           形参：shmid ---》shmget的返回值，表示ID
                                 shmaddr ---》NULL
                                 shmflg ---》0
              三：解除映射
                  shmdt()
                #include <sys/shm.h>
                 int shmdt(const void *shmaddr);
              四：删除共享内存（shmctl功能很多可以删除，可以设置/获取共享内存的属性）
                #include <sys/shm.h>
                int shmctl(int shmid, int cmd, struct shmid_ds *buf);
                      形参：cmd  ---》IPC_RMID  删除（常用的是此功能）
                                      IPC_STAT  获取共享内存的状态信息
                                      IPC_SET   设置共享内存
                            buf  ---》此参数如果你想设置/获取共享内存的状态信息才有用，否则设置NULL
                      struct shmid_ds结构体的定义在/usr/include/i386-linux-gnu/bits/shm.h里面
 小结：
       1.共享内存中的key值多个进程必须保持一致，不然没有办法使用同一块共享内存
 
             （2）消息队列
                  一：创建消息队列
                      msgget()
                #include <sys/msg.h>

                  int msgget(key_t key, int msgflg);
                       返回值：成功返回消息队列的ID
                               失败 -1
                         形参：key
                               msgflg ---》IPC_CREAT  IPC_EXCL
                 二：通过消息队列收发数据
                  #include <sys/msg.h>
                 int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
                        返回值：成功   0
                                失败  -1
                          形参： msgflg ---》默认是0 
                 ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
                        返回值：成功  接收的字节数
                          形参：msgtyp ---》消息的类型
                 三：消息队列的删除
                  #include <sys/msg.h>

                   int msgctl(int msqid, int cmd, struct msqid_ds *buf);
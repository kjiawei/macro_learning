练习：通过消息队列及线程，实现聊天功能
1、创建两个子线程：主线程通过全局变量去控制第一个子线程的退出状态，主线程通过线程销毁方式控制第二个子线程退出。
2、通过线程方式，实现开发板的图片播放同时音乐播放


练习：
1:基于消息队列的通信方式实现一个服务器/客户端模式系统：
	（1）	s服务端从消息队列读取需要计算的两个整数，求和后把结果通过消息队列返回c客户端；
	（2）	c客户端从键盘读取两个整数，通过消息队列发送s服务器，接收到s服务器的计算结果后显示出来
	（3）	要求服务端能同时处理多个客户端的请求(1:n)

	服务器端：
	（1）	初始化；
	（2）	从消息队列获取消息,接收；
	（3）	求和计算；
	（4）	给客户端发送消息
	（5）	转（2）

    客户端：
	（1）	初始化；
	（2）	从键盘获取两个整数；
	（3）	通过消息队列发送两个整数给服务器；
	（4）	接收服务器端消息；
	（5）	转（2）

	struct msgbuf{
		long msgtype;
		int a;
		int b;
		int sum;
	};

练习： 编写一段程序，创建两个子进程，用signal让父进程捕捉SIGINT,
      当捕获到SIGINT,父进程用kill向两个子进程发信号SIGUSR1/SIGUSR2
      当
	发来的信号后，分别输出以下信息及信号的标号后终止
      	Child process 1 is killed my parent：信号标号
	Child process 2 is killed my parent：信号标号

	父进程等待两个子进程终止后，输出以下信息后终止
	Parent process exit;	

售票员司机（可以持续报站）
	用信号模拟司机售票员：创建子进程代表售票员，父进程代表司机，
		1：售票员捕捉SIGINT(代表开车)，发SIGUSR1 给司机，司机捕捉到SIGUSR1 信号后打印“move to next station”
		2: 售票员捕捉SIGQUIT(代表靠站)，发SIGUSR2 给司机，司机捕捉到SIGUSR2 信号后打印“stop the bus”
		3: 司机捕获到SIGTSTP（车到总站），发SIGUSR1给售票员，
		   售票员捕捉到SIGUSR1信号后打印“all get off the bus”，全部进程结束

1、a.用pipe产生一个无名管道之后，再连续产生两个子进程A,B
   b.子进程A往管道写了一句hello后就退出了-------写fd[1];
   c.子进程B读到A写入的数据，再往管道中写入hello world---读fd[0]与fd[1];
   d.主进程读取最后管道中的数据并打印----读fd[0];

2、模拟简单的客户端和服务器端通信，用有名管道实现
	需要两个管道文件
	其中一个是客户端写入，服务器端读取，另一个服务器写入，客户端读取
	客户端写入数据
	服务器把读到的数据做简单处理后返回给客户，反之亦然

	如客户端写入123456，服务器收到后，反馈给客户received:123456
	客户端收到该反馈信息后，会和之前的信息确认，无误才发送下一个信息
	两个进程遇到exit就结束。